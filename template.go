package main

import (
	"bytes"
	"fmt"
	"strings"
	"text/template"

	"golang.org/x/tools/imports"
)

// Import represents a import info that is parsed from the source code.
type Import struct {
	Name string
	Path string
}

// Event represents a event that is parsed from the source code.
type Event struct {
	Name   string
	Params []*EventParam
}

// EventParam represents a event parameter that is parsed from the source code.
type EventParam struct {
	Names []string
	Type  string
}

// EventEmitterParams represents a template parameters for generating event emitter code.
type EventEmitterParams struct {
	Package string
	Imports []*Import
	Events  []*Event
}

var tmpl = template.Must(template.New("EventEmitter").Funcs(template.FuncMap{
	"firstCharToUpper": func(s string) string {
		return strings.ToUpper(s[0:1]) + s[1:]
	},
	"funcParams": func(params []*EventParam) string {
		var results []string
		for _, param := range params {
			names := strings.Join(param.Names, ", ")
			results = append(results, fmt.Sprintf("%s %s", names, param.Type))
		}
		return strings.Join(results, ", ")
	},
	"funcArgNames": func(params []*EventParam) string {
		var results []string
		for _, param := range params {
			names := strings.Join(param.Names, ", ")
			results = append(results, names)
		}
		return strings.Join(results, ", ")
	},
}).Parse(`// Generated by: genem (https://github.com/shiwano/genem)

package {{.Package}}

import (
	"reflect"
	"sync"
{{range .Imports}}
{{if eq .Path "\"sync\""}}
{{else}}
{{if eq .Path "\"reflect\""}}
{{else}}
	{{.Name}} {{.Path}}
{{end}}
{{end}}
{{end}}
)

// {{.Name}} represents an event emitter.
type {{.Name}} struct {
{{range .Events}}
	{{.Name}}Mu *sync.Mutex
	{{.Name}}Listeners []func({{.Params | funcParams}})
	{{.Name}}ListenersOnce []func({{.Params | funcParams}})
{{end}}
}

// New{{.Name}} creates an event emitter.
func New{{.Name}}() *{{.Name}} {
	return &{{.Name}}{
		{{range .Events}}
		{{.Name}}Mu: new(sync.Mutex),
		{{end}}
	}
}

{{range .Events}}
// Emit{{.Name | firstCharToUpper}} emits the specified event.
func (_e *{{$.Name}}) Emit{{.Name | firstCharToUpper}}({{.Params | funcParams}}) {
	_e.{{.Name}}Mu.Lock()
	listeners := make([]func({{.Params | funcParams}}), len(_e.{{.Name}}Listeners))
	copy(listeners, _e.{{.Name}}Listeners)
	listenersOnce := _e.{{.Name}}ListenersOnce
	_e.{{.Name}}ListenersOnce = make([]func({{.Params | funcParams}}), 0)
	_e.{{.Name}}Mu.Unlock()
	for _, l := range listeners {
		l({{.Params | funcArgNames}})
	}
	for _, l := range listenersOnce {
		l({{.Params | funcArgNames}})
	}
}

// Add{{.Name | firstCharToUpper}}Listener registers the specified event listener.
func (_e *{{$.Name}}) Add{{.Name | firstCharToUpper}}Listener(listener func({{.Params | funcParams}})) {
	_e.{{.Name}}Mu.Lock()
	_e.{{.Name}}Listeners = append(_e.{{.Name}}Listeners, listener)
	_e.{{.Name}}Mu.Unlock()
}

// Add{{.Name | firstCharToUpper}}ListenerOnce registers the specified event listener that is invoked only once.
func (_e *{{$.Name}}) Add{{.Name | firstCharToUpper}}ListenerOnce(listener func({{.Params | funcParams}})) {
	_e.{{.Name}}Mu.Lock()
	_e.{{.Name}}ListenersOnce = append(_e.{{.Name}}ListenersOnce, listener)
	_e.{{.Name}}Mu.Unlock()
}

// Remove{{.Name | firstCharToUpper}}Listener removes the event listener previously registered.
func (_e *{{$.Name}}) Remove{{.Name | firstCharToUpper}}Listener(listener func({{.Params | funcParams}})) {
	listenerPtr := reflect.ValueOf(listener).Pointer()
	_e.{{.Name}}Mu.Lock()
	listeners := _e.{{.Name}}Listeners[:0]
	for _, l := range _e.{{.Name}}Listeners {
		if reflect.ValueOf(l).Pointer() != listenerPtr {
			listeners = append(listeners, l)
		}
	}
	_e.{{.Name}}Listeners = listeners
	listenersOnce := _e.{{.Name}}ListenersOnce[:0]
	for _, l := range _e.{{.Name}}ListenersOnce {
		if reflect.ValueOf(l).Pointer() != listenerPtr {
			listenersOnce = append(listenersOnce, l)
		}
	}
	_e.{{.Name}}ListenersOnce = listenersOnce
	_e.{{.Name}}Mu.Unlock()
}
{{end}}`))

func generate(name, fileName string, params *EventEmitterParams) ([]byte, error) {
	var b bytes.Buffer
	err := tmpl.Execute(&b, map[string]interface{}{
		"Package": params.Package,
		"Name":    name,
		"Imports": params.Imports,
		"Events":  params.Events,
	})
	if err != nil {
		return nil, err
	}

	formatted, err := imports.Process(fileName, b.Bytes(), nil)
	if err != nil {
		return nil, err
	}
	return formatted, nil
}
